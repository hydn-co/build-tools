name: "Prune Container Packages"
description: "Removes old pre-release container images from GitHub Container Registry, keeping only the latest N. Never removes stable releases."

inputs:
  org:
    description: "GitHub organization that owns the packages"
    required: true
  package-prefix:
    description: "Package name prefix to filter (e.g., 'mesh-' to match mesh-authd, mesh-brokerd)"
    required: false
    default: ""
  keep-count:
    description: "Number of most recent pre-release images to keep per package"
    required: false
    default: "10"
  dry-run:
    description: "Preview what would be deleted without actually deleting (true/false)"
    required: false
    default: "false"
  token:
    description: "GitHub token with packages:delete scope"
    required: true

outputs:
  deleted-count:
    description: "Total number of package versions deleted (or would be deleted in dry-run)"
    value: ${{ steps.prune.outputs.deleted-count }}
  packages-processed:
    description: "Number of packages processed"
    value: ${{ steps.prune.outputs.packages-processed }}
  total-versions:
    description: "Total package versions found"
    value: ${{ steps.prune.outputs.total-versions }}

runs:
  using: "composite"
  steps:
    - name: Prune Container Package Versions
      id: prune
      shell: bash
      env:
        ORG: ${{ inputs.org }}
        PACKAGE_PREFIX: ${{ inputs.package-prefix }}
        KEEP_COUNT: ${{ inputs.keep-count }}
        DRY_RUN: ${{ inputs.dry-run }}
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        set -euo pipefail

        # Validate inputs
        echo "üîç Validating inputs..."
        if [[ ! "$KEEP_COUNT" =~ ^[0-9]+$ ]]; then
          echo "‚ùå ERROR: Invalid keep-count '$KEEP_COUNT'. Must be a positive integer."
          exit 1
        fi

        if [[ ! "$DRY_RUN" =~ ^(true|false)$ ]]; then
          echo "‚ùå ERROR: Invalid dry-run value '$DRY_RUN'. Must be 'true' or 'false'."
          exit 1
        fi

        if [[ -z "$GITHUB_TOKEN" ]]; then
          echo "‚ùå ERROR: GitHub token is required"
          exit 1
        fi

        echo "üì¶ Fetching container packages for organization: $ORG"
        if [[ -n "$PACKAGE_PREFIX" ]]; then
          echo "   Filtering packages with prefix: $PACKAGE_PREFIX"
        fi

        # Use gh CLI to list packages - more reliable than REST API
        PACKAGE_QUERY='query($org:String!, $first:Int!) { 
          organization(login: $org) { 
            packages(first: $first, packageType: DOCKER) { 
              nodes { 
                name 
              } 
            } 
          } 
        }'

        # Fetch package names using gh CLI
        if ! PACKAGE_DATA=$(gh api graphql -f query="$PACKAGE_QUERY" -f org="$ORG" -F first=100 2>&1); then
          echo "‚ùå ERROR: Failed to fetch packages"
          echo "$PACKAGE_DATA"
          exit 1
        fi

        # Extract package names
        PACKAGE_NAMES=$(echo "$PACKAGE_DATA" | jq -r '.data.organization.packages.nodes[].name' 2>/dev/null || echo "")

        # Filter packages by prefix if specified
        if [[ -n "$PACKAGE_PREFIX" ]]; then
          PACKAGE_NAMES=$(echo "$PACKAGE_NAMES" | grep "^$PACKAGE_PREFIX" || echo "")
        fi

        if [[ -z "$PACKAGE_NAMES" ]]; then
          echo "‚ö†Ô∏è  No packages found matching criteria"
          echo "deleted-count=0" >> "$GITHUB_OUTPUT"
          echo "packages-processed=0" >> "$GITHUB_OUTPUT"
          echo "total-versions=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        PACKAGES_PROCESSED=0
        TOTAL_DELETED=0
        TOTAL_VERSIONS=0

        # Process each package
        while IFS= read -r PACKAGE_NAME; do
          if [[ -z "$PACKAGE_NAME" ]]; then
            continue
          fi

          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ Processing package: $PACKAGE_NAME"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          ((PACKAGES_PROCESSED++))

          # Fetch all versions for this package using gh CLI
          VERSION_QUERY='query($org:String!, $name:String!, $first:Int!) {
            organization(login: $org) {
              packageVersion: registryPackageVersion(packageName: $name) {
                versions(first: $first) {
                  nodes {
                    id
                    version
                    preRelease
                    createdAt
                  }
                }
              }
            }
          }'

          # Try to fetch versions - may not work with all package types
          # Fall back to using API directly for GHCR packages
          VERSIONS=$(gh api graphql -f query="query(\$org:String!, \$name:String!) {
            organization(login: \$org) {
              packages(first: 100, names: [\"\$name\"]) {
                nodes {
                  name
                  versions(first: 100) {
                    nodes {
                      id
                      version
                      preRelease
                      createdAt
                    }
                  }
                }
              }
            }
          }" -f org="$ORG" -f name="$PACKAGE_NAME" 2>&1 || echo '{"errors":[]}')

          # Extract version information
          VERSION_DATA=$(echo "$VERSIONS" | jq -r '.data.organization.packages.nodes[0].versions.nodes[] | "\(.id)|\(.version)|\(.preRelease)|\(.createdAt)"' 2>/dev/null || echo "")

          if [[ -z "$VERSION_DATA" ]]; then
            echo "‚ö†Ô∏è  No versions found for package: $PACKAGE_NAME"
            continue
          fi

          STABLE_VERSIONS=()
          PRERELEASE_VERSIONS=()
          VERSION_IDS=()

          # Parse versions and classify them
          while IFS='|' read -r VERSION_ID TAG IS_PRERELEASE CREATED_AT; do
            if [[ -z "$VERSION_ID" ]]; then
              continue
            fi

            ((TOTAL_VERSIONS++))

            # Use preRelease flag from API instead of parsing tags
            if [[ "$IS_PRERELEASE" == "true" ]]; then
              PRERELEASE_VERSIONS+=("$VERSION_ID|$TAG|$CREATED_AT")
            else
              STABLE_VERSIONS+=("$VERSION_ID|$TAG|$CREATED_AT")
            fi
          done <<< "$VERSION_DATA"

          # Sort pre-release versions by creation date (newest first)
          if [[ ${#PRERELEASE_VERSIONS[@]} -gt 0 ]]; then
            IFS=$'\n' SORTED_PRERELEASES=($(sort -t'|' -k3 -r <<< "${PRERELEASE_VERSIONS[*]}"))
            unset IFS
          else
            SORTED_PRERELEASES=()
          fi

          echo ""
          echo "üìä Version Summary:"
          echo "   Stable releases: ${#STABLE_VERSIONS[@]}"
          echo "   Pre-releases: ${#SORTED_PRERELEASES[@]}"
          echo "   Keeping latest: $KEEP_COUNT pre-releases"

          # Determine which pre-release versions to delete
          VERSIONS_TO_DELETE=()
          VERSIONS_TO_KEEP=()
          
          COUNT=0
          for VERSION_INFO in "${SORTED_PRERELEASES[@]}"; do
            if [[ $COUNT -lt $KEEP_COUNT ]]; then
              VERSIONS_TO_KEEP+=("$VERSION_INFO")
              ((COUNT++))
            else
              VERSIONS_TO_DELETE+=("$VERSION_INFO")
            fi
          done

          echo ""
          echo "‚úÖ Pre-release versions to keep (${#VERSIONS_TO_KEEP[@]}):"
          if [[ ${#VERSIONS_TO_KEEP[@]} -eq 0 ]]; then
            echo "   (none)"
          else
            for VERSION_INFO in "${VERSIONS_TO_KEEP[@]}"; do
              IFS='|' read -r VID VTAG VDATE <<< "$VERSION_INFO"
              # Get all tags for this version
              ALL_TAGS=$(echo "$VERSION_DATA" | grep "^$VID|" | cut -d'|' -f2)
              echo "   - $VTAG (created: ${VDATE:0:10})"
              echo "     Tags: $ALL_TAGS"
            done
          fi

          echo ""
          echo "üóëÔ∏è  Pre-release versions to delete (${#VERSIONS_TO_DELETE[@]}):"
          if [[ ${#VERSIONS_TO_DELETE[@]} -eq 0 ]]; then
            echo "   (none)"
          else
            for VERSION_INFO in "${VERSIONS_TO_DELETE[@]}"; do
              IFS='|' read -r VID VTAG VDATE <<< "$VERSION_INFO"
              # Get all tags for this version
              ALL_TAGS=$(echo "$VERSION_DATA" | grep "^$VID|" | cut -d'|' -f2)
              echo "   - $VTAG (created: ${VDATE:0:10})"
              echo "     All tags to be deleted: $ALL_TAGS"
            done
          fi

          if [[ ${#STABLE_VERSIONS[@]} -gt 0 ]]; then
            echo ""
            echo "üõ°Ô∏è  Stable releases (never deleted):"
            for VERSION_INFO in "${STABLE_VERSIONS[@]}"; do
              IFS='|' read -r VID VTAG VDATE <<< "$VERSION_INFO"
              ALL_TAGS=$(echo "$VERSION_DATA" | grep "^$VID|" | cut -d'|' -f2)
              echo "   - $VTAG (created: ${VDATE:0:10})"
              echo "     Tags: $ALL_TAGS"
            done
          fi

          # Delete versions if not in dry-run mode
          if [[ ${#VERSIONS_TO_DELETE[@]} -gt 0 ]]; then
            if [[ "$DRY_RUN" == "true" ]]; then
              echo ""
              echo "üîç DRY RUN: Would delete ${#VERSIONS_TO_DELETE[@]} versions from $PACKAGE_NAME"
              ((TOTAL_DELETED += ${#VERSIONS_TO_DELETE[@]}))
            else
              echo ""
              echo "üóëÔ∏è  Deleting ${#VERSIONS_TO_DELETE[@]} pre-release versions from $PACKAGE_NAME..."
              
              for VERSION_INFO in "${VERSIONS_TO_DELETE[@]}"; do
                IFS='|' read -r VERSION_ID VTAG VDATE <<< "$VERSION_INFO"
                
                # Delete using gh CLI
                if gh api graphql -f query='mutation($org:String!, $name:String!, $id:String!) {
                  deletePackageVersion(input: {packageVersionId: $id}) {
                    success
                  }
                }' -f org="$ORG" -f name="$PACKAGE_NAME" -f id="$VERSION_ID" &>/dev/null; then
                  echo "   ‚úì Deleted: $VTAG (ID: $VERSION_ID)"
                  ((TOTAL_DELETED++))
                else
                  echo "   ‚ö†Ô∏è  Failed to delete: $VTAG (ID: $VERSION_ID)"
                fi
                
                # Small delay to avoid rate limiting
                sleep 0.5
              done
            fi
          fi

        done <<< "$PACKAGE_NAMES"

        # Final summary
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üìä Cleanup Summary"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "   Packages processed: $PACKAGES_PROCESSED"
        echo "   Total versions found: $TOTAL_VERSIONS"
        echo "   Versions deleted: $TOTAL_DELETED"

        if [[ "$DRY_RUN" == "true" ]]; then
          echo ""
          echo "üîç This was a DRY RUN - no packages were actually deleted"
          echo "   Set dry-run: false to perform actual deletion"
        fi

        # Set outputs
        echo "deleted-count=$TOTAL_DELETED" >> "$GITHUB_OUTPUT"
        echo "packages-processed=$PACKAGES_PROCESSED" >> "$GITHUB_OUTPUT"
        echo "total-versions=$TOTAL_VERSIONS" >> "$GITHUB_OUTPUT"
